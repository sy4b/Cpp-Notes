# 透彻了解inlining的里里外外

`inline`函数，多棒的点子！他们看起来像函数，动作像函数，比宏好得多，可以调用他们又不用蒙受函数调用造成的额外开销。你还能要求更多吗？

你获得的实际上比想到的还多。编译器的最优化机制通常设计用来浓缩哪些“不含函数调用”的代码，所以当你`inline`某个函数，或许比啊一起就能对它执行语境相关最优化

但没有白吃的午餐。`inline`函数的理念是“对于每次调用都以函数本体替换”，这样做可能增加目标码大小，增加内存，以及带来效率的损失

---

`inline`只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。阴郁方式是将函数定义在`class`定义内

```cpp
class Person{
public:
    ...
    int age()const{return theAge;}  // age被定义在class定义式内，隐喻的inline申请
    ...
private:
    int theAge;
}
```

这样的函数通常是成员函数。`friend`函数也可以被定义在`class`内，如果真的这样做，他们也被隐喻声明为`inline`

明确声明`inline`函数的做法实在定义式前加上关键字`inline`。例如标准`max` template往往这样实现

```cpp
template<typename T>
inline const T& std::max(const T& a, const T& b){
    return a<b?b:a;
}
```

---

`max`是个`template`带来一项观察结果：我们发现`inline`函数和`template`两者通常都被定义在头文件中。这使得某些程序员以为function template都必须是`inline`。这个结论无效且可能有害。值得一看

`inline`函数通常一定被放在头文件内，因为把部分建置环境（bulid environment）在编译过程中进行inlining，而将一个“函数调用”替换为：被调用函数的本体“，编译器必须知道这个函数长什么样。

少数编译环境竟可以在运行期完成inlining，但这毕竟是少数

templates通常也被放在头文件内，因为它一旦被使用，编译器为了将它实例化，也需要知道她长什么样子

`template`的具现化和`inline`无关。如果正在写一个`template`而你认为所有根据这个`template`具现出来函数都应该内联，那就应该将这个`template`声明为`inline`（不论显式还是隐式）。否则，就应该避免将这个`template`声明为`inline`。`inline`需要成本

---

大部分编译器拒绝将太过复杂（例如带有循环或者递归）的函数内联，而对于所有的`virtual`函数的调用也将使inlining落空。因为`virtual`意味着到运行期才确定调用哪个函数，而`inline`意味着执行前先将动作替换为函数的本体

---

有时候编译器虽然有意愿inlining某个函数，还是可能为该函数生成一个函数本体

举个例子，如果程序要取某个`inline`函数的地址，编译器通常必须为这个函数生成一个outlined函数本体。毕竟编译器没有能力提出一个指针指向并存在的函数。

与此并提的是，编译器通常不对“通过函数指针进行的调用”实施inlining，这意味着对`inline`函数的调用有可能被inlined，也有可能并没有。这取决于该调用的实施方式

```cpp
inline void f(){...}
void (*pf)()=f;         // pf指向f
...
f();                    // 这个调用将被inlined
pf();                   // 这个调用或许不被inlined      
```

---

即使你从未使用函数指针，未被成功inlined的`inline`函数还是有可能缠住你，因为程序员并非唯一要求函数指针的人

有时候编译器会生成构造函数和析构函数的outlined副本，如此一来他们就可以获得指针指向哪些函数，在`array`内部元素的构造和析构中使用

实际上构造函数和析构函数往往是inlining的糟糕候选人。考虑Derived class构造函数

```cpp
class Base{
public:
    ...
private:
    std::string bm1, bm2;
};

class Derived: public Base{
public:
    Derived(){}                 // 构造函数是空的诶？诶？
    ...
private:
    std::string dm1, dm2, dm3;
};
```

这个构造函数看起来是inlining的绝佳候选人，因为它不含任何代码。但你的眼睛可能会欺骗你

C++对于“对象被创建和销毁时发生了什么事”做了各种保证

例如使用`new`，动态创建的对象呗构造函数自动初始化；使用`delete`时，对应的析构函数被调用。

创建一个对象时，每一个base class以及每一个成员变量都会被自动构造；销毁一个对象，反向程序的析构行为也会自动发生

如果有个异常在对象构造期间被抛出，该对象构造好的那部分会自动销毁。

以上情况中，C++描述了什么一定会发生，但没说如何发生。“事情如何发生”是编译器实现者的责任，但至少他们一定会发生，程序中一定会生成某些代码让事情发生。有时候就放在构造函数和析构函数内。所以如果`inline`，会产生很多的开销

---

从纯粹实用角度出发，一个事实比其他因素更重要：大部分调试器面对`inline`函数都束手无策。毕竟如何在一个并不存在的函数内设置断点呢？

---

# 请记住

- 将大多数inlining限制在小型、频繁被调用的函数身上，这可以使日后的调试和二进制升级更容易，也可以使潜在的代码膨胀问题最小化，是程序速度提升机会最大化
- 不要只因为function templates出现在头文件，就将他们声明为`inline`
