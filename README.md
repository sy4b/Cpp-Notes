## cpp-primer-5th-notes

---

## Effective Modern C++ Notes

### 绪论

[绪论](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Chapter%200.%20绪论.md)

### Chapter 1.型别推导

[条款一：理解型别推导](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%231%20型别推导.md)

[条款二：理解auto型别推导](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%232%20理解auto型别推导.md)

[条款三：理解decltype](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%233%20理解decltype.md)

[条款四：掌握查看型别推导的方法]

### Chapter 2.auto

使用`auto`可以阻止由于手动指定型别带来的潜在错误和性能问题

尽管有些`auto`型别推导结果按部就班符合标准规定的推导算法，但在程序员角度来看是错误的。这种情况下需要知道如何引导`auto`得到正确结果

[条款五：优先选用auto，而非显式型别声明](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%235%20优先选用auto，而非显式型别声明.md)

[条款六：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯语法](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%236%20auto推导的型别不符合要求时，显式型别初始化.md)


### Chapter 3. 转向现代C++

[条款七：创建对象时区分()和{}](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%237%20创建对象时注意区分()和%7B%7D.md)

[条款八：优先选用nullptr](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%238%20优先选用nullptr而非0或NULL.md)

[条款九：优先选用别名声明而不是typedef](https://github.com/sy4b/Cpp-Notes/blob/main/Effective%20C%2B%2B%20Note/Rule%239%20优先选用别名声明而非typedef.md)

---

## Effective C++ Notes

### Chapter 1. 让自己习惯C++

[条款一：视C++为一个语法联邦](https://github.com/sy4b/Cpp-Notes/blob/main/Effeictive%20C%2B%2B%20Notes/Rule%231%20视C%2B%2B为一个语法联邦.md)

[条款二：尽可能以const enum inline替换#define](https://github.com/sy4b/Cpp-Notes/blob/main/Effeictive%20C%2B%2B%20Notes/Rule%232%20尽量以const，enum，inline替换%23defind.md)

[条款三：尽可能使用const](https://github.com/sy4b/Cpp-Notes/blob/main/Effeictive%20C%2B%2B%20Notes/Rule%233%20尽可能使用const.md)

[条款四:确保对象被使用前已经初始化](https://github.com/sy4b/Cpp-Notes/blob/main/Effeictive%20C%2B%2B%20Notes/Rule%234%20确定对象被使用前已被初始化.md)

### Chapter 2. 构造/析构/赋值运算

几乎每写的一个`class`都有一个或多个构造函数、一个析构函数、一个`copy`运算符

[条款五：了解C++默默编写并调用哪些函数]()
